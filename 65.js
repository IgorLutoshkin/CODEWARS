/* 
Примите целое число n (n >= 0) и цифру d (0 <= d <= 9) как целое число.
Возводите в квадрат все числа k (0 <= k <= n) от 0 до n.
Подсчитайте количество цифр d, использованных при написании всех k**2.
Реализуйте функцию, принимающую n и d в качестве параметров и возвращающую это количество.
Примеры:
n = 10, d = 1 
the k*k are 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100
We are using the digit 1 in: 1, 16, 81, 100. The total count is then 4.

The function, when given n = 25 and d = 1 as argument, should return 11 since
the k*k that contain the digit 1 are:
1, 16, 81, 100, 121, 144, 169, 196, 361, 441.
So there are 11 digits 1 for the squares of numbers between 0 and 25.
Обратите внимание, что 121 имеет двойную цифру 1.
*/

function nbDig(n, d) {
  let count = 0;
  for (let i = 0; i <= n; i++) {
    const squared = i ** 2;
    const squaredStr = String(squared);
    const dStr = String(d);
    count += squaredStr.split(dStr).length - 1;
  }

  return count;
}

console.log(nbDig(10, 1)); // ответ 11

/* 
Давайте разберёмся, как работает код `count += (squaredStr.split(dStr).length - 1)`.

1. **Определение переменных**:
   - `squaredStr` — это строковое представление квадрата числа, который мы анализируем.
   - `dStr` — это строковое представление цифры, которую мы ищем.

2. **Метод `split()`**:
   - Метод `split(dStr)` разбивает строку `squaredStr` на массив подстрок, используя `dStr` в качестве разделителя. 
   - Например, если у нас `squaredStr = "100"` и мы ищем `dStr = "1"`, то `squaredStr.split(dStr)` вернёт массив, содержащий `["", "00"]`.

3. **Длина массива**:
   - После разбиения строки `squaredStr` на подстроки, длина полученного массива (`.length`) показывает, сколько подстрок было создано. 
   - В нашем примере выше длина массива будет равна 2 (потому что у нас есть две части: "" и "00").

4. **Вычитание 1**:
   - Когда мы вычитаем 1 из длины массива, мы фактически получаем количество раз, сколько `dStr` (цифра, которую ищем) встречается в `squaredStr`.
   - Почему мы вычитаем 1?  
     - Это связано с тем, что если бы `dStr` никогда не встречался в строке, `split()` возвращает массив длиной 1 (вся строка в качестве единственного элемента).
     - Если `dStr` встречается хотя бы один раз, длина массива будет на одно больше, чем количество вхождений `dStr`. Таким образом, вычитая 1, мы получаем число вхождений `dStr`.

5. **Суммирование**:
   - Оператор `+=` добавляет количество вхождений `dStr`, найденных в `squaredStr`, к переменной `count`, которая хранит общее количество вхождений для всех квадратов чисел от 0 до `n`.

### Пример
Возьмем пример `squaredStr = "100"` и `dStr = "1"`:

```javascript
squaredStr.split(dStr) // ["", "00"]
```

- Длина массива: 2
- Вычитая 1: 2 - 1 = 1

Таким образом, `count` увеличивается на 1, поскольку `1` встречается один раз в строке `"100"`.

Если бы `squaredStr` был, скажем, `"101"`, разбивка дала бы:

```javascript
"101".split("1") // ["", "0", ""]
```

- Длина массива: 3
- Вычитая 1: 3 - 1 = 2

Таким образом, `count` увеличивается на 2, так как `1` встречается дважды в строке `"101"`.

Это и есть механизм, который стоит за записью `count += (squaredStr.split(dStr).length - 1)`.
*/
